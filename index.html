<!DOCTYPE html>
<html>
<head>
  <title>Time Series Analysis in Browser (Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  <style>
    #aiPanel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 400px;
      max-height: 600px;
      background: white;
      border: 2px solid #007bff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      z-index: 1000;
    }
    #aiHeader {
      background: #007bff;
      color: white;
      padding: 12px;
      border-radius: 6px 6px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: move;
    }
    #aiHeader h3 {
      margin: 0;
      font-size: 16px;
    }
    #aiMinimize {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 0 8px;
    }
    #aiMessages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      max-height: 400px;
      min-height: 200px;
    }
    .ai-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      max-width: 85%;
    }
    .ai-message.user {
      background: #e3f2fd;
      margin-left: auto;
      text-align: right;
    }
    .ai-message.assistant {
      background: #f5f5f5;
    }
    #aiControls {
      padding: 8px;
      border-top: 1px solid #ddd;
      display: flex;
      gap: 4px;
    }
    #aiControls button {
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
    }
    #aiControls button:hover {
      background: #f0f0f0;
    }
    #aiInputArea {
      padding: 8px;
      border-top: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #aiInputRow {
      display: flex;
      gap: 8px;
    }
    #aiInput {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    #imagePreview {
      max-width: 100%;
      max-height: 150px;
      margin-top: 4px;
      border-radius: 4px;
      display: none;
    }
    #uploadImage {
      padding: 8px 12px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #removeImage {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: none;
    }
    #imageFileInput {
      display: none;
    }
    #aiSend {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #aiSend:hover {
      background: #0056b3;
    }
    #aiSend:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .typing-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      margin: 0 2px;
      animation: typing 1.4s infinite;
    }
    .typing-indicator:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing {
      0%, 60%, 100% { opacity: 0.3; }
      30% { opacity: 1; }
    }
  </style>
</head>
<body>
  <h2>ðŸ“ˆ CSV Time Series Analysis Tool (Pyodide)</h2>
  <p><b>Upload a CSV file with columns:</b> <code>Date, Close</code> (and optionally Open, High, Low, Volume)</p>
  <input type="file" id="fileInput" accept=".csv"><br>
  <button id="analyzeBtn" style="margin: 10px 0; padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px;" disabled>Analyze</button>
  <div id="output"></div>
  <div id="charts"></div>

  <!-- AI Chat Panel -->
  <div id="aiPanel">
    <div id="aiHeader">
      <h3>ðŸ¤– AI Assistant</h3>
      <button id="aiMinimize">âˆ’</button>
    </div>
    <div id="aiMessages"></div>
    <div id="aiControls">
      <button id="aiStop">Stop</button>
      <button id="aiReset">Reset</button>
      <button id="aiInsertContext">Insert Context</button>
    </div>
    <div id="aiInputArea">
      <img id="imagePreview" alt="Uploaded image" />
      <button id="removeImage">Remove Image</button>
      <div id="aiInputRow">
        <input type="text" id="aiInput" placeholder="Ask a question or upload an image..." />
        <button id="uploadImage">ðŸ“Ž</button>
        <button id="aiSend">Send</button>
      </div>
      <input type="file" id="imageFileInput" accept="image/*" />
    </div>
  </div>

  <script type="text/javascript">
    // Encryption/Decryption functions matching encrypt_keys.py
    const PASSPHRASE = "default_salt_2024";
    
    async function sha256(message) {
      const msgBuffer = new TextEncoder().encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
      return new Uint8Array(hashBuffer);
    }
    
    async function decryptKey(encryptedData, passphrase = PASSPHRASE) {
      try {
        const keyHash = await sha256(passphrase);
        const encryptedBytes = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
        const decrypted = new Uint8Array(encryptedBytes.length);
        
        for (let i = 0; i < encryptedBytes.length; i++) {
          decrypted[i] = encryptedBytes[i] ^ keyHash[i % keyHash.length];
        }
        
        return new TextDecoder().decode(decrypted);
      } catch (e) {
        console.error("Decryption error:", e);
        return "";
      }
    }
    
    // AI Panel functionality
    const OPENAI_KEY_ENCRYPTED = "cOw7g0W4eGXznpOpZzSoOFmOIm04p+lSkou0OhHs9D1LxWarB5lzePb5ss9QHLpgM5w9TQu9xmagjqUtGv/+BG3lXsJgk1oA8orawWIylTpUvw81L6jveoKPlCtUy8AmbekhmX3uIhrCkZrZExCBemLlCXNY87VUh5e/NBfo0DtM/nzHYbxQfOD5h8dKL5ZPVr03dgup2HPxj5IBC/f1BjLgIrI=";
    const MAX_HISTORY_MESSAGES = 500;
    let conversationHistory = [];
    let currentAbortController = null;
    let contextData = "";
    let uploadedImageBase64 = null;
    
    const aiPanel = document.getElementById('aiPanel');
    const aiMessages = document.getElementById('aiMessages');
    const aiInput = document.getElementById('aiInput');
    const aiSend = document.getElementById('aiSend');
    const aiStop = document.getElementById('aiStop');
    const aiReset = document.getElementById('aiReset');
    const aiInsertContext = document.getElementById('aiInsertContext');
    const aiMinimize = document.getElementById('aiMinimize');
    const uploadImageBtn = document.getElementById('uploadImage');
    const imageFileInput = document.getElementById('imageFileInput');
    const imagePreview = document.getElementById('imagePreview');
    const removeImageBtn = document.getElementById('removeImage');
    
    // Make panel draggable
    let isDragging = false;
    let currentX, currentY, initialX, initialY;
    
    document.getElementById('aiHeader').addEventListener('mousedown', (e) => {
      isDragging = true;
      initialX = e.clientX - aiPanel.offsetLeft;
      initialY = e.clientY - aiPanel.offsetTop;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        aiPanel.style.left = currentX + 'px';
        aiPanel.style.top = currentY + 'px';
        aiPanel.style.right = 'auto';
        aiPanel.style.bottom = 'auto';
      }
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    // Minimize toggle
    let isMinimized = false;
    aiMinimize.addEventListener('click', () => {
      isMinimized = !isMinimized;
      if (isMinimized) {
        aiMessages.style.display = 'none';
        aiControls.style.display = 'none';
        aiInputArea.style.display = 'none';
        aiMinimize.textContent = '+';
      } else {
        aiMessages.style.display = 'block';
        aiControls.style.display = 'flex';
        aiInputArea.style.display = 'flex';
        aiMinimize.textContent = 'âˆ’';
      }
    });
    
    function addMessage(content, role = 'assistant') {
      const msgDiv = document.createElement('div');
      msgDiv.className = `ai-message ${role}`;
      msgDiv.textContent = content;
      aiMessages.appendChild(msgDiv);
      aiMessages.scrollTop = aiMessages.scrollHeight;
    }
    
    function addTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'ai-message assistant';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = '<span class="typing-indicator"></span><span class="typing-indicator"></span><span class="typing-indicator"></span>';
      aiMessages.appendChild(typingDiv);
      aiMessages.scrollTop = aiMessages.scrollHeight;
    }
    
    function removeTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) indicator.remove();
    }
    
    async function typeMessage(content) {
      removeTypingIndicator();
      const msgDiv = document.createElement('div');
      msgDiv.className = 'ai-message assistant';
      aiMessages.appendChild(msgDiv);
      
      let index = 0;
      const speed = 20;
      
      return new Promise((resolve) => {
        const typeChar = () => {
          if (index < content.length) {
            msgDiv.textContent += content.charAt(index);
            index++;
            aiMessages.scrollTop = aiMessages.scrollHeight;
            setTimeout(typeChar, speed);
          } else {
            resolve();
          }
        };
        typeChar();
      });
    }
    
    async function sendMessage() {
      const message = aiInput.value.trim();
      if (!message && !uploadedImageBase64) return;
      
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured. Please set OPENAI_KEY_ENCRYPTED.", 'assistant');
        return;
      }
      
      addMessage(message || "[Image analysis]", 'user');
      aiInput.value = '';
      
      // Build user message with optional image
      let userMessage;
      if (uploadedImageBase64) {
        userMessage = {
          role: 'user',
          content: [
            { type: 'text', text: message || 'Analyze this chart and provide insights.' },
            { type: 'image_url', image_url: { url: uploadedImageBase64 } }
          ]
        };
        uploadedImageBase64 = null;
        imagePreview.style.display = 'none';
        removeImageBtn.style.display = 'none';
        imageFileInput.value = '';
      } else {
        userMessage = { role: 'user', content: message };
      }
      
      conversationHistory.push(userMessage);
      
      // Limit history to last 500 messages
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addTypingIndicator();
      aiSend.disabled = true;
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        
        currentAbortController = new AbortController();
        
        const messages = contextData 
          ? [{ role: 'system', content: `Stock Analysis Context: ${contextData}` }, ...conversationHistory]
          : conversationHistory;
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 500
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        aiSend.disabled = false;
        currentAbortController = null;
      }
    }
    
    aiSend.addEventListener('click', sendMessage);
    
    aiInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });
    
    aiStop.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
      }
    });
    
    aiReset.addEventListener('click', () => {
      conversationHistory = [];
      aiMessages.innerHTML = '';
      contextData = "";
      addMessage('Conversation reset.', 'assistant');
    });
    
    aiInsertContext.addEventListener('click', () => {
      const outputText = document.getElementById('output').textContent;
      if (outputText) {
        contextData = outputText;
        addMessage('âœ“ Context inserted from analysis output.', 'assistant');
      } else {
        addMessage('âš ï¸ No context available. Run analysis first.', 'assistant');
      }
    });
    
    // Image upload support
    uploadImageBtn.addEventListener('click', () => {
      imageFileInput.click();
    });
    
    imageFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          uploadedImageBase64 = event.target.result;
          imagePreview.src = uploadedImageBase64;
          imagePreview.style.display = 'block';
          removeImageBtn.style.display = 'block';
          addMessage('âœ“ Image uploaded. Ask about it!', 'assistant');
        };
        reader.readAsDataURL(file);
      }
    });
    
    // Paste image support
    aiInput.addEventListener('paste', async (e) => {
      const items = e.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf('image') !== -1) {
          e.preventDefault();
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = (event) => {
            uploadedImageBase64 = event.target.result;
            imagePreview.src = uploadedImageBase64;
            imagePreview.style.display = 'block';
            removeImageBtn.style.display = 'block';
            addMessage('âœ“ Image pasted. Ask about it!', 'assistant');
          };
          reader.readAsDataURL(blob);
          break;
        }
      }
    });
    
    removeImageBtn.addEventListener('click', () => {
      uploadedImageBase64 = null;
      imagePreview.style.display = 'none';
      removeImageBtn.style.display = 'none';
      imageFileInput.value = '';
    });

    // Original analysis code
    let pyodideReady = loadPyodide();
    let uploadedFileContent = null;

    async function analyzeCSV(fileContent) {
      try {
        const pyodide = await pyodideReady;
        
        document.getElementById("output").textContent = "Loading packages...";
        document.getElementById("charts").innerHTML = "";
        
        await pyodide.loadPackage(['pandas', 'numpy', 'matplotlib']);
        
        document.getElementById("output").textContent = "Packages loaded. Processing data...";

        pyodide.FS.writeFile("uploaded.csv", fileContent);

      await pyodide.runPythonAsync(`
        import pandas as pd
        import matplotlib.pyplot as plt
        import numpy as np
        import io, base64
        from js import document

        df = pd.read_csv("uploaded.csv")

        # Clean data - handle various column name formats
        df.columns = df.columns.str.strip()
        
        # Create a mapping for common column name variations
        column_mapping = {}
        for col in df.columns:
            col_lower = col.lower()
            if col_lower in ['date', 'timestamp', 'time']:
                column_mapping[col] = 'Date'
            elif col_lower in ['close', 'closing_price', 'adj close', 'adj_close']:
                column_mapping[col] = 'Close'
            elif col_lower in ['open', 'opening_price']:
                column_mapping[col] = 'Open'
            elif col_lower in ['high', 'high_price']:
                column_mapping[col] = 'High'
            elif col_lower in ['low', 'low_price']:
                column_mapping[col] = 'Low'
            elif col_lower in ['volume', 'vol', 'trading_volume']:
                column_mapping[col] = 'Volume'
        
        df = df.rename(columns=column_mapping)
        
        # Check for required columns
        if 'Date' not in df.columns:
            raise ValueError(f"CSV must have a date column. Found columns: {list(df.columns)}")
        
        if 'Close' not in df.columns:
            raise ValueError(f"CSV must have a 'Close' price column. Found columns: {list(df.columns)}")
        
        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
        df = df.dropna(subset=['Date', 'Close'])
        df = df.sort_values('Date')
        df.set_index('Date', inplace=True)
        df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
        df.dropna(subset=['Close'], inplace=True)

        document.getElementById("output").innerHTML = f"<p><b>ðŸ“… Date Range:</b> {df.index.min().date()} to {df.index.max().date()}</p><p><b>ðŸ”¢ Rows:</b> {len(df)}</p><p><b>ðŸ§¾ Columns:</b> {', '.join(df.columns)}</p>"

        # Add return + volatility
        df['Return'] = df['Close'].pct_change()
        df['Volatility'] = df['Return'].rolling(30).std() * 100
        df['MA_50'] = df['Close'].rolling(50).mean()
        df['MA_200'] = df['Close'].rolling(200).mean()

        def show_plot(title):
            buf = io.BytesIO()
            plt.tight_layout()
            plt.savefig(buf, format='png', bbox_inches='tight')
            plt.close()
            img_str = "data:image/png;base64," + base64.b64encode(buf.getvalue()).decode('utf-8')
            document.getElementById("charts").innerHTML += f"<h4>{title}</h4><img src='{img_str}' style='max-width:100%; height:auto;'><br>"

        # Trend
        plt.figure(figsize=(10,4))
        df['Close'].plot(color='black')
        plt.title("Trend: Close Price")
        show_plot("Trend: Close Price")

        # Volatility
        plt.figure(figsize=(10,4))
        df['Volatility'].plot(color='black')
        plt.title("30-Day Rolling Volatility (%)")
        show_plot("30-Day Rolling Volatility (%)")

        # Moving Averages
        plt.figure(figsize=(10,4))
        df[['Close', 'MA_50', 'MA_200']].plot()
        plt.title("Moving Averages (50 & 200)")
        show_plot("Moving Averages (50 & 200)")

        # Yearly returns
        yr = df['Close'].resample('Y').last().pct_change()*100
        plt.figure(figsize=(10,4))
        yr.dropna().plot(kind='bar', color='black')
        plt.title("Yearly Returns (%)")
        show_plot("Yearly Returns (%)")

        # Monthly return heatmap
        monthly = df['Close'].resample('M').last().pct_change() * 100
        mdf = monthly.to_frame(name="Return")
        mdf['Year'] = mdf.index.year
        mdf['Month'] = mdf.index.month_name()
        pivot = mdf.pivot(index="Year", columns="Month", values="Return")
        month_order = ['January','February','March','April','May','June','July','August','September','October','November','December']
        pivot = pivot.reindex(columns=month_order)
        
        heatmap_array = pivot.to_numpy(dtype=float)
        finite_mask = np.isfinite(heatmap_array)
        max_abs = np.nanmax(np.abs(heatmap_array[finite_mask])) if finite_mask.any() else 1
        if not np.isfinite(max_abs) or max_abs == 0:
            max_abs = 1
        heatmap_masked = np.ma.masked_invalid(heatmap_array)
        
        plt.figure(figsize=(12,5))
        fig, ax = plt.subplots(figsize=(12, 5))
        im = ax.imshow(
            heatmap_masked,
            cmap="RdYlGn",
            aspect="auto",
            vmin=-max_abs,
            vmax=max_abs,
        )
        ax.set_xticks(range(len(pivot.columns)))
        ax.set_xticklabels(pivot.columns, rotation=45, ha="right")
        ax.set_yticks(range(len(pivot.index)))
        ax.set_yticklabels([str(y) for y in pivot.index])
        ax.set_title("Monthly Return Heatmap")
        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
        cbar.set_label("% Return")
        
        for i, year in enumerate(pivot.index):
            for j, month in enumerate(pivot.columns):
                value = pivot.iloc[i, j]
                if pd.notna(value):
                    ax.text(j, i, f"{value:.1f}", ha="center", va="center", fontsize=8, color="black")
        
        plt.tight_layout()
        show_plot("Monthly Return Heatmap")

        # Seasonal avg
        seasonal = mdf.groupby("Month")['Return'].mean().reindex(month_order)
        plt.figure(figsize=(10,4))
        seasonal.plot(kind='bar', color='black')
        plt.title("Seasonal Monthly Average Return")
        show_plot("Seasonal Monthly Average Return")
      `);
      
      document.getElementById("output").innerHTML += "<p style='color: green;'><b>âœ“ Analysis complete!</b></p>";
      } catch (error) {
        document.getElementById("output").innerHTML = `<p style='color: red;'><b>Error:</b> ${error.message}</p>`;
        console.error(error);
      }
    }

    document.getElementById("fileInput").addEventListener("change", async (evt) => {
      const file = evt.target.files[0];
      if (!file) {
        document.getElementById("analyzeBtn").disabled = true;
        return;
      }
      
      const arrayBuffer = await file.arrayBuffer();
      uploadedFileContent = new Uint8Array(arrayBuffer);
      
      document.getElementById("output").textContent = `File "${file.name}" loaded. Click Analyze to process.`;
      document.getElementById("charts").innerHTML = "";
      document.getElementById("analyzeBtn").disabled = false;
    });

    document.getElementById("analyzeBtn").addEventListener("click", async () => {
      if (!uploadedFileContent) {
        alert("Please upload a CSV file first.");
        return;
      }
      await analyzeCSV(uploadedFileContent);
    });
  </script>
</body>
</html>
