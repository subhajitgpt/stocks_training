<!DOCTYPE html>
<html>
<head>
  <title>Time Series Analysis in Browser (Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 20px;
      border-bottom: 2px solid #ddd;
    }
    .tab {
      padding: 12px 24px;
      background: #f0f0f0;
      border: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s;
    }
    .tab:hover {
      background: #e0e0e0;
    }
    .tab.active {
      background: white;
      color: #007bff;
      border-bottom: 2px solid #007bff;
    }
    .tab-content {
      display: none;
      background: white;
      padding: 20px;
      border-radius: 0 8px 8px 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .tab-content.active {
      display: block;
    }
    #chartContainer {
      width: 100%;
      height: 600px;
      position: relative;
      background: #1e222d;
      border-radius: 8px;
    }
    #candlestickChart {
      width: 100%;
      height: 100%;
    }
    .stock-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      background: #1e222d;
      color: white;
      border-radius: 8px 8px 0 0;
      margin: -20px -20px 20px -20px;
    }
    .stock-info h2 {
      margin: 0 0 8px 0;
      font-size: 20px;
      color: white;
    }
    .stock-info .price-data {
      display: flex;
      gap: 16px;
      font-size: 14px;
      color: #b2b5be;
    }
    .price-data span {
      display: flex;
      gap: 4px;
    }
    .price-change {
      color: #26a69a;
      font-weight: bold;
    }
    .price-change.negative {
      color: #ef5350;
    }
    #aiPanel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 400px;
      max-height: 600px;
      background: white;
      border: 2px solid #007bff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      z-index: 1000;
    }
    #aiHeader {
      background: #007bff;
      color: white;
      padding: 12px;
      border-radius: 6px 6px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: move;
    }
    #aiHeader h3 {
      margin: 0;
      font-size: 16px;
    }
    #aiMinimize {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 0 8px;
    }
    #aiMessages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      max-height: 400px;
      min-height: 200px;
    }
    .ai-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      max-width: 85%;
    }
    .ai-message.user {
      background: #e3f2fd;
      margin-left: auto;
      text-align: right;
    }
    .ai-message.assistant {
      background: #f5f5f5;
    }
    #aiControls {
      padding: 8px;
      border-top: 1px solid #ddd;
      display: flex;
      gap: 4px;
    }
    #aiControls button {
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
    }
    #aiControls button:hover {
      background: #f0f0f0;
    }
    #aiInputArea {
      padding: 8px;
      border-top: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #aiInputRow {
      display: flex;
      gap: 8px;
    }
    #aiInput {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    #imagePreview {
      max-width: 100%;
      max-height: 150px;
      margin-top: 4px;
      border-radius: 4px;
      display: none;
    }
    #uploadImage {
      padding: 8px 12px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #removeImage {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: none;
    }
    #imageFileInput {
      display: none;
    }
    #aiSend {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #aiSend:hover {
      background: #0056b3;
    }
    #aiSend:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .typing-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      margin: 0 2px;
      animation: typing 1.4s infinite;
    }
    .typing-indicator:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing {
      0%, 60%, 100% { opacity: 0.3; }
      30% { opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" onclick="switchTab('analysis')">ðŸ“Š Analysis</button>
    <button class="tab" onclick="switchTab('chart')">ðŸ“ˆ Candlestick Chart</button>
  </div>

  <!-- Tab 1: Analysis -->
  <div id="analysisTab" class="tab-content active">
    <h2>ðŸ“ˆ Time Series Analysis Tool</h2>
    <p><b>Upload a CSV file with columns:</b> <code>Date, Close</code> (and optionally Open, High, Low, Volume)</p>
    <input type="file" id="fileInput" accept=".csv"><br>
    <button id="analyzeBtn" style="margin: 10px 0; padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px;" disabled>Analyze</button>
    <div id="output"></div>
    <div id="charts"></div>
  </div>

  <!-- Tab 2: Candlestick Chart -->
  <div id="chartTab" class="tab-content">
    <div class="stock-header">
      <div class="stock-info">
        <h2 id="stockTitle">Stock Data Â· 1D Â· NSE</h2>
        <div class="price-data">
          <span>O <span id="openPrice">--</span></span>
          <span>H <span id="highPrice">--</span></span>
          <span>L <span id="lowPrice">--</span></span>
          <span>C <span id="closePrice">--</span></span>
          <span class="price-change" id="priceChange">-- (--)</span>
        </div>
      </div>
    </div>
    <input type="file" id="fileInputChart" accept=".csv" style="margin-bottom: 16px;">
    <div id="chartContainer">
      <canvas id="candlestickChart"></canvas>
    </div>
  </div>

  <!-- AI Chat Panel -->
  <div id="aiPanel">
    <div id="aiHeader">
      <h3>ðŸ¤– AI Assistant</h3>
      <button id="aiMinimize">âˆ’</button>
    </div>
    <div id="aiMessages"></div>
    <div id="aiControls">
      <button id="aiStop">Stop</button>
      <button id="aiReset">Reset</button>
      <button id="aiInsertContext">Insert Context</button>
    </div>
    <div id="aiInputArea">
      <img id="imagePreview" alt="Uploaded image" />
      <button id="removeImage">Remove Image</button>
      <div id="aiInputRow">
        <input type="text" id="aiInput" placeholder="Ask a question or upload an image..." />
        <button id="uploadImage">ðŸ“Ž</button>
        <button id="aiSend">Send</button>
      </div>
      <input type="file" id="imageFileInput" accept="image/*" />
    </div>
  </div>

  <script type="text/javascript">
    // Tab switching functionality
    function switchTab(tabName) {
      const tabs = document.querySelectorAll('.tab');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabs.forEach(tab => tab.classList.remove('active'));
      tabContents.forEach(content => content.classList.remove('active'));
      
      if (tabName === 'analysis') {
        document.getElementById('analysisTab').classList.add('active');
        tabs[0].classList.add('active');
      } else if (tabName === 'chart') {
        document.getElementById('chartTab').classList.add('active');
        tabs[1].classList.add('active');
      }
    }

    // Candlestick chart variables
    let chartData = [];
    let hoveredCandle = null;
    let chartMetrics = null;
    
    // Candlestick chart drawing function
    function drawCandlestickChart(data, hoverIndex = null) {
      const canvas = document.getElementById('candlestickChart');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      const width = canvas.width;
      const height = canvas.height;
      const padding = { top: 40, right: 80, bottom: 80, left: 60 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;
      
      // Clear canvas
      ctx.fillStyle = '#1e222d';
      ctx.fillRect(0, 0, width, height);
      
      if (data.length === 0) return;
      
      // Display last 100 candles for better visibility
      const displayData = data.slice(-100);
      
      // Calculate price range
      const prices = displayData.flatMap(d => [d.high, d.low]);
      const maxPrice = Math.max(...prices);
      const minPrice = Math.min(...prices);
      const priceRange = maxPrice - minPrice;
      const priceMargin = priceRange * 0.1;
      
      // Helper functions
      const getY = (price) => {
        return padding.top + chartHeight - ((price - minPrice + priceMargin) / (priceRange + 2 * priceMargin)) * chartHeight;
      };
      
      const candleWidth = Math.max(2, chartWidth / displayData.length * 0.7);
      const candleSpacing = chartWidth / displayData.length;
      
      // Store metrics for hover detection
      chartMetrics = {
        padding,
        candleSpacing,
        candleWidth,
        displayData,
        chartWidth,
        chartHeight,
        getY
      };
      
      // Draw "Price" label on Y-axis
      ctx.save();
      ctx.fillStyle = '#b2b5be';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.translate(20, padding.top + chartHeight / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Price (â‚¹)', 0, 0);
      ctx.restore();
      
      // Draw grid lines with price labels
      ctx.strokeStyle = '#2a2e39';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const price = minPrice + (priceRange * i / 5);
        const y = getY(price);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
        
        // Price labels on right
        ctx.fillStyle = '#b2b5be';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('â‚¹' + price.toFixed(2), width - padding.right + 5, y + 4);
      }
      
      // Draw candlesticks
      displayData.forEach((candle, i) => {
        const x = padding.left + (i * candleSpacing) + (candleSpacing / 2);
        const isGreen = candle.close >= candle.open;
        
        // Wick (high-low line)
        ctx.strokeStyle = isGreen ? '#26a69a' : '#ef5350';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, getY(candle.high));
        ctx.lineTo(x, getY(candle.low));
        ctx.stroke();
        
        // Body (open-close rectangle)
        const bodyTop = Math.min(getY(candle.open), getY(candle.close));
        const bodyBottom = Math.max(getY(candle.open), getY(candle.close));
        const bodyHeight = Math.max(1, bodyBottom - bodyTop);
        
        ctx.fillStyle = isGreen ? '#26a69a' : '#ef5350';
        ctx.fillRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
      });
      
      // Draw date labels on X-axis
      ctx.fillStyle = '#b2b5be';
      ctx.font = '11px Arial';
      ctx.textAlign = 'center';
      
      // Show date labels at intervals
      const labelInterval = Math.max(1, Math.floor(displayData.length / 8));
      for (let i = 0; i < displayData.length; i += labelInterval) {
        const x = padding.left + (i * candleSpacing) + (candleSpacing / 2);
        const date = displayData[i].date;
        const dateStr = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: '2-digit' });
        
        // Draw tick mark
        ctx.strokeStyle = '#2a2e39';
        ctx.beginPath();
        ctx.moveTo(x, padding.top + chartHeight);
        ctx.lineTo(x, padding.top + chartHeight + 5);
        ctx.stroke();
        
        // Draw date label
        ctx.save();
        ctx.translate(x, padding.top + chartHeight + 20);
        ctx.rotate(-Math.PI / 4);
        ctx.fillText(dateStr, 0, 0);
        ctx.restore();
      }
      
      // Draw "Date" label on X-axis
      ctx.fillStyle = '#b2b5be';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Date', padding.left + chartWidth / 2, height - 10);
      
      // Draw volume bars at bottom
      const volumeHeight = 60;
      const volumeTop = padding.top + chartHeight + 10;
      const maxVolume = Math.max(...displayData.map(d => d.volume));
      
      displayData.forEach((candle, i) => {
        const x = padding.left + (i * candleSpacing) + (candleSpacing / 2);
        const isGreen = candle.close >= candle.open;
        const barHeight = (candle.volume / maxVolume) * volumeHeight;
        
        ctx.fillStyle = isGreen ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)';
        ctx.fillRect(x - candleWidth/2, volumeTop + volumeHeight - barHeight, candleWidth, barHeight);
      });
      
      // Volume label
      ctx.fillStyle = '#b2b5be';
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('Volume: ' + (displayData[displayData.length-1].volume / 1000000).toFixed(2) + 'M', padding.left, volumeTop - 5);
      
      // Draw legend
      ctx.fillStyle = '#b2b5be';
      ctx.font = '12px Arial';
      ctx.textAlign = 'right';
      ctx.fillText('ðŸŸ© Bullish (Close â‰¥ Open)  ðŸŸ¥ Bearish (Close < Open)', width - padding.right, 25);
      
      // Draw hover tooltip
      if (hoverIndex !== null && hoverIndex >= 0 && hoverIndex < displayData.length) {
        const candle = displayData[hoverIndex];
        const x = padding.left + (hoverIndex * candleSpacing) + (candleSpacing / 2);
        
        // Draw vertical crosshair
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, padding.top + chartHeight);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw tooltip box
        const tooltipWidth = 180;
        const tooltipHeight = 120;
        let tooltipX = x + 15;
        let tooltipY = padding.top + 50;
        
        // Keep tooltip within canvas bounds
        if (tooltipX + tooltipWidth > width - padding.right) {
          tooltipX = x - tooltipWidth - 15;
        }
        
        // Draw tooltip background
        ctx.fillStyle = 'rgba(30, 34, 45, 0.95)';
        ctx.strokeStyle = '#4a4e59';
        ctx.lineWidth = 1;
        ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
        
        // Draw tooltip content
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 13px Arial';
        ctx.textAlign = 'left';
        const dateStr = candle.date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
        ctx.fillText(dateStr, tooltipX + 10, tooltipY + 20);
        
        ctx.font = '12px Arial';
        ctx.fillStyle = '#b2b5be';
        const lines = [
          { label: 'Open:', value: 'â‚¹' + candle.open.toFixed(2), color: '#b2b5be' },
          { label: 'High:', value: 'â‚¹' + candle.high.toFixed(2), color: '#26a69a' },
          { label: 'Low:', value: 'â‚¹' + candle.low.toFixed(2), color: '#ef5350' },
          { label: 'Close:', value: 'â‚¹' + candle.close.toFixed(2), color: '#ffffff' },
          { label: 'Volume:', value: (candle.volume / 1000000).toFixed(2) + 'M', color: '#b2b5be' }
        ];
        
        lines.forEach((line, i) => {
          ctx.fillStyle = '#b2b5be';
          ctx.fillText(line.label, tooltipX + 10, tooltipY + 45 + (i * 15));
          ctx.fillStyle = line.color;
          ctx.textAlign = 'right';
          ctx.fillText(line.value, tooltipX + tooltipWidth - 10, tooltipY + 45 + (i * 15));
          ctx.textAlign = 'left';
        });
        
        // Update header with hovered candle data
        document.getElementById('openPrice').textContent = candle.open.toFixed(2);
        document.getElementById('highPrice').textContent = candle.high.toFixed(2);
        document.getElementById('lowPrice').textContent = candle.low.toFixed(2);
        document.getElementById('closePrice').textContent = candle.close.toFixed(2);
      }
    }
    
    // Load CSV for candlestick chart
    document.getElementById('fileInputChart').addEventListener('change', async (evt) => {
      const file = evt.target.files[0];
      if (!file) return;
      
      const text = await file.text();
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());
      
      chartData = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        const row = {};
        headers.forEach((h, idx) => {
          row[h] = values[idx];
        });
        
        // Parse date formats like "17/05/2022"
        const dateParts = row['Date'].split('/');
        const date = new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);
        
        chartData.push({
          date: date,
          open: parseFloat(row['Open']),
          high: parseFloat(row['High']),
          low: parseFloat(row['Low']),
          close: parseFloat(row['Close']),
          volume: parseFloat(row['Volume'])
        });
      }
      
      // Update stock header with latest data
      if (chartData.length > 0) {
        const latest = chartData[chartData.length - 1];
        const previous = chartData[chartData.length - 2];
        const change = latest.close - previous.close;
        const changePercent = (change / previous.close) * 100;
        
        document.getElementById('openPrice').textContent = latest.open.toFixed(2);
        document.getElementById('highPrice').textContent = latest.high.toFixed(2);
        document.getElementById('lowPrice').textContent = latest.low.toFixed(2);
        document.getElementById('closePrice').textContent = latest.close.toFixed(2);
        
        const priceChangeEl = document.getElementById('priceChange');
        priceChangeEl.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)} (${change >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
        priceChangeEl.className = change >= 0 ? 'price-change' : 'price-change negative';
      }
      
      drawCandlestickChart(chartData);
    });
    
    // Add mouse move event for hover tooltips
    document.getElementById('candlestickChart').addEventListener('mousemove', (e) => {
      if (!chartMetrics || chartData.length === 0) return;
      
      const canvas = document.getElementById('candlestickChart');
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Check if mouse is within chart area
      const { padding, candleSpacing, displayData, chartWidth, chartHeight } = chartMetrics;
      
      if (mouseX >= padding.left && mouseX <= padding.left + chartWidth &&
          mouseY >= padding.top && mouseY <= padding.top + chartHeight) {
        
        // Calculate which candle is being hovered
        const relativeX = mouseX - padding.left;
        const index = Math.floor(relativeX / candleSpacing);
        
        if (index >= 0 && index < displayData.length) {
          hoveredCandle = index;
          drawCandlestickChart(chartData, hoveredCandle);
          canvas.style.cursor = 'crosshair';
          return;
        }
      }
      
      // Mouse outside chart area
      if (hoveredCandle !== null) {
        hoveredCandle = null;
        drawCandlestickChart(chartData);
        
        // Reset header to latest data
        if (chartData.length > 0) {
          const latest = chartData[chartData.length - 1];
          document.getElementById('openPrice').textContent = latest.open.toFixed(2);
          document.getElementById('highPrice').textContent = latest.high.toFixed(2);
          document.getElementById('lowPrice').textContent = latest.low.toFixed(2);
          document.getElementById('closePrice').textContent = latest.close.toFixed(2);
        }
      }
      canvas.style.cursor = 'default';
    });
    
    // Reset on mouse leave
    document.getElementById('candlestickChart').addEventListener('mouseleave', () => {
      if (hoveredCandle !== null) {
        hoveredCandle = null;
        drawCandlestickChart(chartData);
        
        // Reset header to latest data
        if (chartData.length > 0) {
          const latest = chartData[chartData.length - 1];
          document.getElementById('openPrice').textContent = latest.open.toFixed(2);
          document.getElementById('highPrice').textContent = latest.high.toFixed(2);
          document.getElementById('lowPrice').textContent = latest.low.toFixed(2);
          document.getElementById('closePrice').textContent = latest.close.toFixed(2);
        }
      }
      document.getElementById('candlestickChart').style.cursor = 'default';
    });
    
    // Redraw chart on window resize
    window.addEventListener('resize', () => {
      if (chartData.length > 0) {
        drawCandlestickChart(chartData);
      }
    });

    // Encryption/Decryption functions matching encrypt_keys.py
    const PASSPHRASE = "default_salt_2024";
    
    async function sha256(message) {
      const msgBuffer = new TextEncoder().encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
      return new Uint8Array(hashBuffer);
    }
    
    async function decryptKey(encryptedData, passphrase = PASSPHRASE) {
      try {
        const keyHash = await sha256(passphrase);
        const encryptedBytes = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
        const decrypted = new Uint8Array(encryptedBytes.length);
        
        for (let i = 0; i < encryptedBytes.length; i++) {
          decrypted[i] = encryptedBytes[i] ^ keyHash[i % keyHash.length];
        }
        
        return new TextDecoder().decode(decrypted);
      } catch (e) {
        console.error("Decryption error:", e);
        return "";
      }
    }
    
    // AI Panel functionality
    const OPENAI_KEY_ENCRYPTED = "cOw7g0W4eGXznpOpZzSoOFmOIm04p+lSkou0OhHs9D1LxWarB5lzePb5ss9QHLpgM5w9TQu9xmagjqUtGv/+BG3lXsJgk1oA8orawWIylTpUvw81L6jveoKPlCtUy8AmbekhmX3uIhrCkZrZExCBemLlCXNY87VUh5e/NBfo0DtM/nzHYbxQfOD5h8dKL5ZPVr03dgup2HPxj5IBC/f1BjLgIrI=";
    const MAX_HISTORY_MESSAGES = 500;
    let conversationHistory = [];
    let currentAbortController = null;
    let contextData = "";
    let uploadedImageBase64 = null;
    
    const aiPanel = document.getElementById('aiPanel');
    const aiMessages = document.getElementById('aiMessages');
    const aiInput = document.getElementById('aiInput');
    const aiSend = document.getElementById('aiSend');
    const aiStop = document.getElementById('aiStop');
    const aiReset = document.getElementById('aiReset');
    const aiInsertContext = document.getElementById('aiInsertContext');
    const aiMinimize = document.getElementById('aiMinimize');
    const uploadImageBtn = document.getElementById('uploadImage');
    const imageFileInput = document.getElementById('imageFileInput');
    const imagePreview = document.getElementById('imagePreview');
    const removeImageBtn = document.getElementById('removeImage');
    
    // Make panel draggable
    let isDragging = false;
    let currentX, currentY, initialX, initialY;
    
    document.getElementById('aiHeader').addEventListener('mousedown', (e) => {
      isDragging = true;
      initialX = e.clientX - aiPanel.offsetLeft;
      initialY = e.clientY - aiPanel.offsetTop;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        aiPanel.style.left = currentX + 'px';
        aiPanel.style.top = currentY + 'px';
        aiPanel.style.right = 'auto';
        aiPanel.style.bottom = 'auto';
      }
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    // Minimize toggle
    let isMinimized = false;
    aiMinimize.addEventListener('click', () => {
      isMinimized = !isMinimized;
      if (isMinimized) {
        aiMessages.style.display = 'none';
        aiControls.style.display = 'none';
        aiInputArea.style.display = 'none';
        aiMinimize.textContent = '+';
      } else {
        aiMessages.style.display = 'block';
        aiControls.style.display = 'flex';
        aiInputArea.style.display = 'flex';
        aiMinimize.textContent = 'âˆ’';
      }
    });
    
    function addMessage(content, role = 'assistant') {
      const msgDiv = document.createElement('div');
      msgDiv.className = `ai-message ${role}`;
      msgDiv.textContent = content;
      aiMessages.appendChild(msgDiv);
      aiMessages.scrollTop = aiMessages.scrollHeight;
    }
    
    function addTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'ai-message assistant';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = '<span class="typing-indicator"></span><span class="typing-indicator"></span><span class="typing-indicator"></span>';
      aiMessages.appendChild(typingDiv);
      aiMessages.scrollTop = aiMessages.scrollHeight;
    }
    
    function removeTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) indicator.remove();
    }
    
    async function typeMessage(content) {
      removeTypingIndicator();
      const msgDiv = document.createElement('div');
      msgDiv.className = 'ai-message assistant';
      aiMessages.appendChild(msgDiv);
      
      let index = 0;
      const speed = 20;
      
      return new Promise((resolve) => {
        const typeChar = () => {
          if (index < content.length) {
            msgDiv.textContent += content.charAt(index);
            index++;
            aiMessages.scrollTop = aiMessages.scrollHeight;
            setTimeout(typeChar, speed);
          } else {
            resolve();
          }
        };
        typeChar();
      });
    }
    
    async function getAIRecommendation() {
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured.", 'assistant');
        return;
      }
      
      const recommendationPrompt = `Based on the following stock analysis data and technical indicators, provide a brief investment recommendation and key insights:\n\n${contextData}\n\nConsider the RSI, moving averages, volatility, and overall trend. Provide: 1) Market sentiment, 2) Key technical signals, 3) Risk assessment, 4) Short-term outlook.`;
      
      conversationHistory.push({ role: 'user', content: recommendationPrompt });
      
      // Limit history
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addMessage("ðŸ¤– Analyzing data and generating recommendation...", 'assistant');
      addTypingIndicator();
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        currentAbortController = new AbortController();
        
        const messages = [{ role: 'system', content: 'You are a financial analyst assistant. Provide clear, actionable insights based on technical analysis data.' }, ...conversationHistory];
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 800
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        removeTypingIndicator();
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        currentAbortController = null;
      }
    }
    
    async function getAIRecommendation() {
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured.", 'assistant');
        return;
      }
      
      const recommendationPrompt = `Based on the following stock analysis data and technical indicators, provide a brief investment recommendation and key insights:\n\n${contextData}\n\nConsider the RSI, moving averages, volatility, and overall trend. Provide: 1) Market sentiment, 2) Key technical signals, 3) Risk assessment, 4) Short-term outlook.`;
      
      conversationHistory.push({ role: 'user', content: recommendationPrompt });
      
      // Limit history
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addMessage("ðŸ¤– Analyzing data and generating recommendation...", 'assistant');
      addTypingIndicator();
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        currentAbortController = new AbortController();
        
        const messages = [{ role: 'system', content: 'You are a financial analyst assistant. Provide clear, actionable insights based on technical analysis data.' }, ...conversationHistory];
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 800
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        removeTypingIndicator();
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        currentAbortController = null;
      }
    }
    
    async function sendMessage() {
      const message = aiInput.value.trim();
      if (!message && !uploadedImageBase64) return;
      
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured. Please set OPENAI_KEY_ENCRYPTED.", 'assistant');
        return;
      }
      
      addMessage(message || "[Image analysis]", 'user');
      aiInput.value = '';
      
      // Build user message with optional image
      let userMessage;
      if (uploadedImageBase64) {
        userMessage = {
          role: 'user',
          content: [
            { type: 'text', text: message || 'Analyze this chart and provide insights.' },
            { type: 'image_url', image_url: { url: uploadedImageBase64 } }
          ]
        };
        uploadedImageBase64 = null;
        imagePreview.style.display = 'none';
        removeImageBtn.style.display = 'none';
        imageFileInput.value = '';
      } else {
        userMessage = { role: 'user', content: message };
      }
      
      conversationHistory.push(userMessage);
      
      // Limit history to last 500 messages
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addTypingIndicator();
      aiSend.disabled = true;
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        
        currentAbortController = new AbortController();
        
        const messages = contextData 
          ? [{ role: 'system', content: `Stock Analysis Context: ${contextData}` }, ...conversationHistory]
          : conversationHistory;
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 500
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        aiSend.disabled = false;
        currentAbortController = null;
      }
    }
    
    aiSend.addEventListener('click', sendMessage);
    
    aiInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });
    
    aiStop.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
      }
    });
    
    aiReset.addEventListener('click', () => {
      conversationHistory = [];
      aiMessages.innerHTML = '';
      contextData = "";
      addMessage('Conversation reset.', 'assistant');
    });
    
    aiInsertContext.addEventListener('click', () => {
      const outputText = document.getElementById('output').textContent;
      if (outputText) {
        contextData = outputText;
        addMessage('âœ“ Context inserted from analysis output.', 'assistant');
      } else {
        addMessage('âš ï¸ No context available. Run analysis first.', 'assistant');
      }
    });
    
    // Image upload support
    uploadImageBtn.addEventListener('click', () => {
      imageFileInput.click();
    });
    
    imageFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          uploadedImageBase64 = event.target.result;
          imagePreview.src = uploadedImageBase64;
          imagePreview.style.display = 'block';
          removeImageBtn.style.display = 'block';
          addMessage('âœ“ Image uploaded. Ask about it!', 'assistant');
        };
        reader.readAsDataURL(file);
      }
    });
    
    // Paste image support
    aiInput.addEventListener('paste', async (e) => {
      const items = e.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf('image') !== -1) {
          e.preventDefault();
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = (event) => {
            uploadedImageBase64 = event.target.result;
            imagePreview.src = uploadedImageBase64;
            imagePreview.style.display = 'block';
            removeImageBtn.style.display = 'block';
            addMessage('âœ“ Image pasted. Ask about it!', 'assistant');
          };
          reader.readAsDataURL(blob);
          break;
        }
      }
    });
    
    removeImageBtn.addEventListener('click', () => {
      uploadedImageBase64 = null;
      imagePreview.style.display = 'none';
      removeImageBtn.style.display = 'none';
      imageFileInput.value = '';
    });

    // Original analysis code
    let pyodideReady = loadPyodide();
    let uploadedFileContent = null;

    async function analyzeCSV(fileContent) {
      try {
        const pyodide = await pyodideReady;
        
        document.getElementById("output").textContent = "Loading packages...";
        document.getElementById("charts").innerHTML = "";
        
        await pyodide.loadPackage(['pandas', 'numpy', 'matplotlib']);
        
        document.getElementById("output").textContent = "Packages loaded. Processing data...";

        pyodide.FS.writeFile("uploaded.csv", fileContent);

      await pyodide.runPythonAsync(`
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import io, base64
from js import document

df = pd.read_csv("uploaded.csv")

# Clean data - handle various column name formats
df.columns = df.columns.str.strip()

# Replace spaces with underscores in column names
df.columns = df.columns.str.replace(' ', '_', regex=False)

# Handle duplicate column names by adding suffixes
cols = pd.Series(df.columns)
for dup in cols[cols.duplicated()].unique():
    cols[cols[cols == dup].index.values.tolist()] = [dup + '_' + str(i) if i != 0 else dup for i in range(sum(cols == dup))]
df.columns = cols

# Create a mapping for common column name variations
column_mapping = {}
for col in df.columns:
    col_lower = col.lower()
    if col_lower in ['date', 'timestamp', 'time']:
        column_mapping[col] = 'Date'
    elif col_lower in ['close', 'closing_price', 'adj close', 'adj_close']:
        column_mapping[col] = 'Close'
    elif col_lower in ['open', 'opening_price']:
        column_mapping[col] = 'Open'
    elif col_lower in ['high', 'high_price']:
        column_mapping[col] = 'High'
    elif col_lower in ['low', 'low_price']:
        column_mapping[col] = 'Low'
    elif col_lower in ['volume', 'vol', 'trading_volume']:
        column_mapping[col] = 'Volume'

df = df.rename(columns=column_mapping)

# Handle duplicate columns after mapping (keep first occurrence)
df = df.loc[:, ~df.columns.duplicated(keep='first')]

# Check for required columns
if 'Date' not in df.columns:
    raise ValueError(f"CSV must have a date column. Found columns: {list(df.columns)}")

if 'Close' not in df.columns:
    raise ValueError(f"CSV must have a 'Close' price column. Found columns: {list(df.columns)}")

# Defensive: Clean all numeric columns - remove commas and convert to numeric
for col in df.columns:
    if col != 'Date':
        # Ensure we're working with a Series, convert to string, remove commas, convert to numeric
        series_data = df[col] if isinstance(df[col], pd.Series) else df[col].iloc[:, 0]
        series_data = series_data.astype(str).str.replace(',', '', regex=False)
        df[col] = pd.to_numeric(series_data, errors='coerce')

df['Date'] = pd.to_datetime(df['Date'], errors='coerce', dayfirst=True)
df = df.dropna(subset=['Date', 'Close'])
df = df.sort_values('Date')
df.set_index('Date', inplace=True)

document.getElementById("output").innerHTML = f"<p><b>ðŸ“… Date Range:</b> {df.index.min().date()} to {df.index.max().date()}</p><p><b>ðŸ”¢ Rows:</b> {len(df)}</p><p><b>ðŸ§¾ Columns:</b> {', '.join(df.columns)}</p>"

# Add return + volatility
df['Return'] = df['Close'].pct_change()
df['Volatility'] = df['Return'].rolling(30).std() * 100
df['MA_50'] = df['Close'].rolling(50).mean()
df['MA_200'] = df['Close'].rolling(200).mean()

# Calculate RSI (Relative Strength Index)
delta = df['Close'].diff()
gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
rs = gain / loss
df['RSI'] = 100 - (100 / (1 + rs))

def show_plot(title):
    buf = io.BytesIO()
    plt.tight_layout()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close()
    img_str = "data:image/png;base64," + base64.b64encode(buf.getvalue()).decode('utf-8')
    document.getElementById("charts").innerHTML += f"<h4>{title}</h4><img src='{img_str}' style='max-width:100%; height:auto;'><br>"

# Trend
plt.figure(figsize=(10,4))
df['Close'].plot(color='black')
plt.title("Trend: Close Price")
show_plot("Trend: Close Price")

# Volatility
plt.figure(figsize=(10,4))
df['Volatility'].plot(color='black')
plt.title("30-Day Rolling Volatility (%)")
show_plot("30-Day Rolling Volatility (%)")

# Moving Averages
plt.figure(figsize=(10,4))
df[['Close', 'MA_50', 'MA_200']].plot()
plt.title("Moving Averages (50 & 200)")
show_plot("Moving Averages (50 & 200)")

# RSI (Relative Strength Index)
plt.figure(figsize=(10,4))
df['RSI'].plot(color='purple')
plt.axhline(y=70, color='r', linestyle='--', label='Overbought (70)')
plt.axhline(y=30, color='g', linestyle='--', label='Oversold (30)')
plt.title("RSI (14-period)")
plt.ylabel("RSI")
plt.legend()
plt.ylim(0, 100)
show_plot("RSI (14-period)")

# Yearly returns
yr = df['Close'].resample('Y').last().pct_change()*100
plt.figure(figsize=(10,4))
yr.dropna().plot(kind='bar', color='black')
plt.title("Yearly Returns (%)")
show_plot("Yearly Returns (%)")

# Monthly return heatmap
monthly = df['Close'].resample('M').last().pct_change() * 100
mdf = monthly.to_frame(name="Return")
mdf['Year'] = mdf.index.year
mdf['Month'] = mdf.index.month_name()
pivot = mdf.pivot(index="Year", columns="Month", values="Return")
month_order = ['January','February','March','April','May','June','July','August','September','October','November','December']
pivot = pivot.reindex(columns=month_order)

heatmap_array = pivot.to_numpy(dtype=float)
finite_mask = np.isfinite(heatmap_array)
max_abs = np.nanmax(np.abs(heatmap_array[finite_mask])) if finite_mask.any() else 1
if not np.isfinite(max_abs) or max_abs == 0:
    max_abs = 1
heatmap_masked = np.ma.masked_invalid(heatmap_array)

plt.figure(figsize=(12,5))
fig, ax = plt.subplots(figsize=(12, 5))
im = ax.imshow(
    heatmap_masked,
    cmap="RdYlGn",
    aspect="auto",
    vmin=-max_abs,
    vmax=max_abs,
)
ax.set_xticks(range(len(pivot.columns)))
ax.set_xticklabels(pivot.columns, rotation=45, ha="right")
ax.set_yticks(range(len(pivot.index)))
ax.set_yticklabels([str(y) for y in pivot.index])
ax.set_title("Monthly Return Heatmap")
cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
cbar.set_label("% Return")

for i, year in enumerate(pivot.index):
    for j, month in enumerate(pivot.columns):
        value = pivot.iloc[i, j]
        if pd.notna(value):
            ax.text(j, i, f"{value:.1f}", ha="center", va="center", fontsize=8, color="black")

plt.tight_layout()
show_plot("Monthly Return Heatmap")

# Seasonal avg
seasonal = mdf.groupby("Month")['Return'].mean().reindex(month_order)
plt.figure(figsize=(10,4))
seasonal.plot(kind='bar', color='black')
plt.title("Seasonal Monthly Average Return")
show_plot("Seasonal Monthly Average Return")

# Prepare analysis summary for AI context
latest_price = df['Close'].iloc[-1]
latest_rsi = df['RSI'].iloc[-1]
price_change_pct = ((df['Close'].iloc[-1] - df['Close'].iloc[0]) / df['Close'].iloc[0]) * 100
avg_volatility = df['Volatility'].mean()
current_volatility = df['Volatility'].iloc[-1]

ma_signal = "neutral"
if df['Close'].iloc[-1] > df['MA_50'].iloc[-1] > df['MA_200'].iloc[-1]:
    ma_signal = "bullish (Golden Cross pattern)"
elif df['Close'].iloc[-1] < df['MA_50'].iloc[-1] < df['MA_200'].iloc[-1]:
    ma_signal = "bearish (Death Cross pattern)"

rsi_signal = "neutral"
if latest_rsi > 70:
    rsi_signal = "overbought (>70)"
elif latest_rsi < 30:
    rsi_signal = "oversold (<30)"

analysis_summary = """
ðŸ“Š Stock Analysis Summary:
- Date Range: """ + str(df.index.min().date()) + """ to """ + str(df.index.max().date()) + """
- Total Trading Days: """ + str(len(df)) + """
- Current Price: $""" + f"{latest_price:.2f}" + """
- Price Change: """ + f"{price_change_pct:.2f}" + """% over period
- RSI (14-day): """ + f"{latest_rsi:.2f}" + """ (""" + rsi_signal + """)
- Current Volatility: """ + f"{current_volatility:.2f}" + """%
- Average Volatility: """ + f"{avg_volatility:.2f}" + """%
- Moving Average Signal: """ + ma_signal + """
- 50-Day MA: $""" + f"{df['MA_50'].iloc[-1]:.2f}" + """
- 200-Day MA: $""" + f"{df['MA_200'].iloc[-1]:.2f}" + """
"""

# Return the summary to JavaScript
analysis_summary
      `);
      
      // Store the analysis summary in context and auto-request recommendation
      contextData = pyodide.runPython('analysis_summary');
      document.getElementById("output").innerHTML += "<p style='color: green;'><b>âœ“ Analysis complete!</b></p>";
      
      // Automatically get AI recommendation
      await getAIRecommendation();
      } catch (error) {
        document.getElementById("output").innerHTML = `<p style='color: red;'><b>Error:</b> ${error.message}</p>`;
        console.error(error);
      }
    }

    document.getElementById("fileInput").addEventListener("change", async (evt) => {
      const file = evt.target.files[0];
      if (!file) {
        document.getElementById("analyzeBtn").disabled = true;
        return;
      }
      
      const arrayBuffer = await file.arrayBuffer();
      uploadedFileContent = new Uint8Array(arrayBuffer);
      
      document.getElementById("output").textContent = `File "${file.name}" loaded. Click Analyze to process.`;
      document.getElementById("charts").innerHTML = "";
      document.getElementById("analyzeBtn").disabled = false;
    });

    document.getElementById("analyzeBtn").addEventListener("click", async () => {
      if (!uploadedFileContent) {
        alert("Please upload a CSV file first.");
        return;
      }
      await analyzeCSV(uploadedFileContent);
    });
  </script>
</body>
</html>
