<!DOCTYPE html>
<html>
<head>
  <title>Time Series Analysis in Browser (Pyodide)</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  <style>
    #aiPanel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 400px;
      max-height: 600px;
      background: white;
      border: 2px solid #007bff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      z-index: 1000;
    }
    #aiHeader {
      background: #007bff;
      color: white;
      padding: 12px;
      border-radius: 6px 6px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: move;
    }
    #aiHeader h3 {
      margin: 0;
      font-size: 16px;
    }
    #aiMinimize {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 0 8px;
    }
    #aiMessages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      max-height: 400px;
      min-height: 200px;
    }
    .ai-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 6px;
      max-width: 85%;
    }
    .ai-message.user {
      background: #e3f2fd;
      margin-left: auto;
      text-align: right;
    }
    .ai-message.assistant {
      background: #f5f5f5;
    }
    #aiControls {
      padding: 8px;
      border-top: 1px solid #ddd;
      display: flex;
      gap: 4px;
    }
    #aiControls button {
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
    }
    #aiControls button:hover {
      background: #f0f0f0;
    }
    #aiInputArea {
      padding: 8px;
      border-top: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #aiInputRow {
      display: flex;
      gap: 8px;
    }
    #aiInput {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    #imagePreview {
      max-width: 100%;
      max-height: 150px;
      margin-top: 4px;
      border-radius: 4px;
      display: none;
    }
    #uploadImage {
      padding: 8px 12px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #removeImage {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: none;
    }
    #imageFileInput {
      display: none;
    }
    #aiSend {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #aiSend:hover {
      background: #0056b3;
    }
    #aiSend:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .typing-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      margin: 0 2px;
      animation: typing 1.4s infinite;
    }
    .typing-indicator:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing {
      0%, 60%, 100% { opacity: 0.3; }
      30% { opacity: 1; }
    }
  </style>
</head>
<body>
  <h2>ðŸ“ˆ CSV Time Series Analysis Tool (Pyodide)</h2>
  <p><b>Upload a CSV file with columns:</b> <code>Date, Close</code> (and optionally Open, High, Low, Volume)</p>
  <input type="file" id="fileInput" accept=".csv"><br>
  <button id="analyzeBtn" style="margin: 10px 0; padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px;" disabled>Analyze</button>
  <div id="output"></div>
  <div id="charts"></div>

  <!-- AI Chat Panel -->
  <div id="aiPanel">
    <div id="aiHeader">
      <h3>ðŸ¤– AI Assistant</h3>
      <button id="aiMinimize">âˆ’</button>
    </div>
    <div id="aiMessages"></div>
    <div id="aiControls">
      <button id="aiStop">Stop</button>
      <button id="aiReset">Reset</button>
      <button id="aiInsertContext">Insert Context</button>
    </div>
    <div id="aiInputArea">
      <img id="imagePreview" alt="Uploaded image" />
      <button id="removeImage">Remove Image</button>
      <div id="aiInputRow">
        <input type="text" id="aiInput" placeholder="Ask a question or upload an image..." />
        <button id="uploadImage">ðŸ“Ž</button>
        <button id="aiSend">Send</button>
      </div>
      <input type="file" id="imageFileInput" accept="image/*" />
    </div>
  </div>

  <script type="text/javascript">
    // Encryption/Decryption functions matching encrypt_keys.py
    const PASSPHRASE = "default_salt_2024";
    
    async function sha256(message) {
      const msgBuffer = new TextEncoder().encode(message);
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
      return new Uint8Array(hashBuffer);
    }
    
    async function decryptKey(encryptedData, passphrase = PASSPHRASE) {
      try {
        const keyHash = await sha256(passphrase);
        const encryptedBytes = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
        const decrypted = new Uint8Array(encryptedBytes.length);
        
        for (let i = 0; i < encryptedBytes.length; i++) {
          decrypted[i] = encryptedBytes[i] ^ keyHash[i % keyHash.length];
        }
        
        return new TextDecoder().decode(decrypted);
      } catch (e) {
        console.error("Decryption error:", e);
        return "";
      }
    }
    
    // AI Panel functionality
    const OPENAI_KEY_ENCRYPTED = "cOw7g0W4eGXznpOpZzSoOFmOIm04p+lSkou0OhHs9D1LxWarB5lzePb5ss9QHLpgM5w9TQu9xmagjqUtGv/+BG3lXsJgk1oA8orawWIylTpUvw81L6jveoKPlCtUy8AmbekhmX3uIhrCkZrZExCBemLlCXNY87VUh5e/NBfo0DtM/nzHYbxQfOD5h8dKL5ZPVr03dgup2HPxj5IBC/f1BjLgIrI=";
    const MAX_HISTORY_MESSAGES = 500;
    let conversationHistory = [];
    let currentAbortController = null;
    let contextData = "";
    let uploadedImageBase64 = null;
    
    const aiPanel = document.getElementById('aiPanel');
    const aiMessages = document.getElementById('aiMessages');
    const aiInput = document.getElementById('aiInput');
    const aiSend = document.getElementById('aiSend');
    const aiStop = document.getElementById('aiStop');
    const aiReset = document.getElementById('aiReset');
    const aiInsertContext = document.getElementById('aiInsertContext');
    const aiMinimize = document.getElementById('aiMinimize');
    const uploadImageBtn = document.getElementById('uploadImage');
    const imageFileInput = document.getElementById('imageFileInput');
    const imagePreview = document.getElementById('imagePreview');
    const removeImageBtn = document.getElementById('removeImage');
    
    // Make panel draggable
    let isDragging = false;
    let currentX, currentY, initialX, initialY;
    
    document.getElementById('aiHeader').addEventListener('mousedown', (e) => {
      isDragging = true;
      initialX = e.clientX - aiPanel.offsetLeft;
      initialY = e.clientY - aiPanel.offsetTop;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        aiPanel.style.left = currentX + 'px';
        aiPanel.style.top = currentY + 'px';
        aiPanel.style.right = 'auto';
        aiPanel.style.bottom = 'auto';
      }
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    // Minimize toggle
    let isMinimized = false;
    aiMinimize.addEventListener('click', () => {
      isMinimized = !isMinimized;
      if (isMinimized) {
        aiMessages.style.display = 'none';
        aiControls.style.display = 'none';
        aiInputArea.style.display = 'none';
        aiMinimize.textContent = '+';
      } else {
        aiMessages.style.display = 'block';
        aiControls.style.display = 'flex';
        aiInputArea.style.display = 'flex';
        aiMinimize.textContent = 'âˆ’';
      }
    });
    
    function addMessage(content, role = 'assistant') {
      const msgDiv = document.createElement('div');
      msgDiv.className = `ai-message ${role}`;
      msgDiv.textContent = content;
      aiMessages.appendChild(msgDiv);
      aiMessages.scrollTop = aiMessages.scrollHeight;
    }
    
    function addTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'ai-message assistant';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = '<span class="typing-indicator"></span><span class="typing-indicator"></span><span class="typing-indicator"></span>';
      aiMessages.appendChild(typingDiv);
      aiMessages.scrollTop = aiMessages.scrollHeight;
    }
    
    function removeTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) indicator.remove();
    }
    
    async function typeMessage(content) {
      removeTypingIndicator();
      const msgDiv = document.createElement('div');
      msgDiv.className = 'ai-message assistant';
      aiMessages.appendChild(msgDiv);
      
      let index = 0;
      const speed = 20;
      
      return new Promise((resolve) => {
        const typeChar = () => {
          if (index < content.length) {
            msgDiv.textContent += content.charAt(index);
            index++;
            aiMessages.scrollTop = aiMessages.scrollHeight;
            setTimeout(typeChar, speed);
          } else {
            resolve();
          }
        };
        typeChar();
      });
    }
    
    async function getAIRecommendation() {
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured.", 'assistant');
        return;
      }
      
      const recommendationPrompt = `Based on the following stock analysis data and technical indicators, provide a brief investment recommendation and key insights:\n\n${contextData}\n\nConsider the RSI, moving averages, volatility, and overall trend. Provide: 1) Market sentiment, 2) Key technical signals, 3) Risk assessment, 4) Short-term outlook.`;
      
      conversationHistory.push({ role: 'user', content: recommendationPrompt });
      
      // Limit history
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addMessage("ðŸ¤– Analyzing data and generating recommendation...", 'assistant');
      addTypingIndicator();
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        currentAbortController = new AbortController();
        
        const messages = [{ role: 'system', content: 'You are a financial analyst assistant. Provide clear, actionable insights based on technical analysis data.' }, ...conversationHistory];
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 800
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        removeTypingIndicator();
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        currentAbortController = null;
      }
    }
    
    async function getAIRecommendation() {
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured.", 'assistant');
        return;
      }
      
      const recommendationPrompt = `Based on the following stock analysis data and technical indicators, provide a brief investment recommendation and key insights:\n\n${contextData}\n\nConsider the RSI, moving averages, volatility, and overall trend. Provide: 1) Market sentiment, 2) Key technical signals, 3) Risk assessment, 4) Short-term outlook.`;
      
      conversationHistory.push({ role: 'user', content: recommendationPrompt });
      
      // Limit history
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addMessage("ðŸ¤– Analyzing data and generating recommendation...", 'assistant');
      addTypingIndicator();
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        currentAbortController = new AbortController();
        
        const messages = [{ role: 'system', content: 'You are a financial analyst assistant. Provide clear, actionable insights based on technical analysis data.' }, ...conversationHistory];
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 800
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        removeTypingIndicator();
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        currentAbortController = null;
      }
    }
    
    async function sendMessage() {
      const message = aiInput.value.trim();
      if (!message && !uploadedImageBase64) return;
      
      if (!OPENAI_KEY_ENCRYPTED) {
        addMessage("âš ï¸ OpenAI API key not configured. Please set OPENAI_KEY_ENCRYPTED.", 'assistant');
        return;
      }
      
      addMessage(message || "[Image analysis]", 'user');
      aiInput.value = '';
      
      // Build user message with optional image
      let userMessage;
      if (uploadedImageBase64) {
        userMessage = {
          role: 'user',
          content: [
            { type: 'text', text: message || 'Analyze this chart and provide insights.' },
            { type: 'image_url', image_url: { url: uploadedImageBase64 } }
          ]
        };
        uploadedImageBase64 = null;
        imagePreview.style.display = 'none';
        removeImageBtn.style.display = 'none';
        imageFileInput.value = '';
      } else {
        userMessage = { role: 'user', content: message };
      }
      
      conversationHistory.push(userMessage);
      
      // Limit history to last 500 messages
      if (conversationHistory.length > MAX_HISTORY_MESSAGES) {
        conversationHistory = conversationHistory.slice(-MAX_HISTORY_MESSAGES);
      }
      
      addTypingIndicator();
      aiSend.disabled = true;
      
      try {
        const apiKey = await decryptKey(OPENAI_KEY_ENCRYPTED);
        
        currentAbortController = new AbortController();
        
        const messages = contextData 
          ? [{ role: 'system', content: `Stock Analysis Context: ${contextData}` }, ...conversationHistory]
          : conversationHistory;
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.7,
            max_tokens: 500
          }),
          signal: currentAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        const reply = data.choices[0].message.content;
        
        conversationHistory.push({ role: 'assistant', content: reply });
        await typeMessage(reply);
        
      } catch (error) {
        removeTypingIndicator();
        if (error.name === 'AbortError') {
          addMessage('âš ï¸ Request stopped by user.', 'assistant');
        } else {
          addMessage(`âš ï¸ Error: ${error.message}`, 'assistant');
        }
      } finally {
        aiSend.disabled = false;
        currentAbortController = null;
      }
    }
    
    aiSend.addEventListener('click', sendMessage);
    
    aiInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });
    
    aiStop.addEventListener('click', () => {
      if (currentAbortController) {
        currentAbortController.abort();
      }
    });
    
    aiReset.addEventListener('click', () => {
      conversationHistory = [];
      aiMessages.innerHTML = '';
      contextData = "";
      addMessage('Conversation reset.', 'assistant');
    });
    
    aiInsertContext.addEventListener('click', () => {
      const outputText = document.getElementById('output').textContent;
      if (outputText) {
        contextData = outputText;
        addMessage('âœ“ Context inserted from analysis output.', 'assistant');
      } else {
        addMessage('âš ï¸ No context available. Run analysis first.', 'assistant');
      }
    });
    
    // Image upload support
    uploadImageBtn.addEventListener('click', () => {
      imageFileInput.click();
    });
    
    imageFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          uploadedImageBase64 = event.target.result;
          imagePreview.src = uploadedImageBase64;
          imagePreview.style.display = 'block';
          removeImageBtn.style.display = 'block';
          addMessage('âœ“ Image uploaded. Ask about it!', 'assistant');
        };
        reader.readAsDataURL(file);
      }
    });
    
    // Paste image support
    aiInput.addEventListener('paste', async (e) => {
      const items = e.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf('image') !== -1) {
          e.preventDefault();
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = (event) => {
            uploadedImageBase64 = event.target.result;
            imagePreview.src = uploadedImageBase64;
            imagePreview.style.display = 'block';
            removeImageBtn.style.display = 'block';
            addMessage('âœ“ Image pasted. Ask about it!', 'assistant');
          };
          reader.readAsDataURL(blob);
          break;
        }
      }
    });
    
    removeImageBtn.addEventListener('click', () => {
      uploadedImageBase64 = null;
      imagePreview.style.display = 'none';
      removeImageBtn.style.display = 'none';
      imageFileInput.value = '';
    });

    // Original analysis code
    let pyodideReady = loadPyodide();
    let uploadedFileContent = null;

    async function analyzeCSV(fileContent) {
      try {
        const pyodide = await pyodideReady;
        
        document.getElementById("output").textContent = "Loading packages...";
        document.getElementById("charts").innerHTML = "";
        
        await pyodide.loadPackage(['pandas', 'numpy', 'matplotlib']);
        
        document.getElementById("output").textContent = "Packages loaded. Processing data...";

        pyodide.FS.writeFile("uploaded.csv", fileContent);

      await pyodide.runPythonAsync(`
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import io, base64
from js import document

df = pd.read_csv("uploaded.csv")

# Clean data - handle various column name formats
df.columns = df.columns.str.strip()

# Replace spaces with underscores in column names
df.columns = df.columns.str.replace(' ', '_', regex=False)

# Handle duplicate column names by adding suffixes
cols = pd.Series(df.columns)
for dup in cols[cols.duplicated()].unique():
    cols[cols[cols == dup].index.values.tolist()] = [dup + '_' + str(i) if i != 0 else dup for i in range(sum(cols == dup))]
df.columns = cols

# Create a mapping for common column name variations
column_mapping = {}
for col in df.columns:
    col_lower = col.lower()
    if col_lower in ['date', 'timestamp', 'time']:
        column_mapping[col] = 'Date'
    elif col_lower in ['close', 'closing_price', 'adj close', 'adj_close']:
        column_mapping[col] = 'Close'
    elif col_lower in ['open', 'opening_price']:
        column_mapping[col] = 'Open'
    elif col_lower in ['high', 'high_price']:
        column_mapping[col] = 'High'
    elif col_lower in ['low', 'low_price']:
        column_mapping[col] = 'Low'
    elif col_lower in ['volume', 'vol', 'trading_volume']:
        column_mapping[col] = 'Volume'

df = df.rename(columns=column_mapping)

# Handle duplicate columns after mapping (keep first occurrence)
df = df.loc[:, ~df.columns.duplicated(keep='first')]

# Check for required columns
if 'Date' not in df.columns:
    raise ValueError(f"CSV must have a date column. Found columns: {list(df.columns)}")

if 'Close' not in df.columns:
    raise ValueError(f"CSV must have a 'Close' price column. Found columns: {list(df.columns)}")

# Defensive: Clean all numeric columns - remove commas and convert to numeric
for col in df.columns:
    if col != 'Date':
        # Ensure we're working with a Series, convert to string, remove commas, convert to numeric
        series_data = df[col] if isinstance(df[col], pd.Series) else df[col].iloc[:, 0]
        series_data = series_data.astype(str).str.replace(',', '', regex=False)
        df[col] = pd.to_numeric(series_data, errors='coerce')

df['Date'] = pd.to_datetime(df['Date'], errors='coerce', dayfirst=True)
df = df.dropna(subset=['Date', 'Close'])
df = df.sort_values('Date')
df.set_index('Date', inplace=True)

document.getElementById("output").innerHTML = f"<p><b>ðŸ“… Date Range:</b> {df.index.min().date()} to {df.index.max().date()}</p><p><b>ðŸ”¢ Rows:</b> {len(df)}</p><p><b>ðŸ§¾ Columns:</b> {', '.join(df.columns)}</p>"

# Add return + volatility
df['Return'] = df['Close'].pct_change()
df['Volatility'] = df['Return'].rolling(30).std() * 100
df['MA_50'] = df['Close'].rolling(50).mean()
df['MA_200'] = df['Close'].rolling(200).mean()

# Calculate RSI (Relative Strength Index)
delta = df['Close'].diff()
gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
rs = gain / loss
df['RSI'] = 100 - (100 / (1 + rs))

def show_plot(title):
    buf = io.BytesIO()
    plt.tight_layout()
    plt.savefig(buf, format='png', bbox_inches='tight')
    plt.close()
    img_str = "data:image/png;base64," + base64.b64encode(buf.getvalue()).decode('utf-8')
    document.getElementById("charts").innerHTML += f"<h4>{title}</h4><img src='{img_str}' style='max-width:100%; height:auto;'><br>"

# Trend
plt.figure(figsize=(10,4))
df['Close'].plot(color='black')
plt.title("Trend: Close Price")
show_plot("Trend: Close Price")

# Volatility
plt.figure(figsize=(10,4))
df['Volatility'].plot(color='black')
plt.title("30-Day Rolling Volatility (%)")
show_plot("30-Day Rolling Volatility (%)")

# Moving Averages
plt.figure(figsize=(10,4))
df[['Close', 'MA_50', 'MA_200']].plot()
plt.title("Moving Averages (50 & 200)")
show_plot("Moving Averages (50 & 200)")

# RSI (Relative Strength Index)
plt.figure(figsize=(10,4))
df['RSI'].plot(color='purple')
plt.axhline(y=70, color='r', linestyle='--', label='Overbought (70)')
plt.axhline(y=30, color='g', linestyle='--', label='Oversold (30)')
plt.title("RSI (14-period)")
plt.ylabel("RSI")
plt.legend()
plt.ylim(0, 100)
show_plot("RSI (14-period)")

# Yearly returns
yr = df['Close'].resample('Y').last().pct_change()*100
plt.figure(figsize=(10,4))
yr.dropna().plot(kind='bar', color='black')
plt.title("Yearly Returns (%)")
show_plot("Yearly Returns (%)")

# Monthly return heatmap
monthly = df['Close'].resample('M').last().pct_change() * 100
mdf = monthly.to_frame(name="Return")
mdf['Year'] = mdf.index.year
mdf['Month'] = mdf.index.month_name()
pivot = mdf.pivot(index="Year", columns="Month", values="Return")
month_order = ['January','February','March','April','May','June','July','August','September','October','November','December']
pivot = pivot.reindex(columns=month_order)

heatmap_array = pivot.to_numpy(dtype=float)
finite_mask = np.isfinite(heatmap_array)
max_abs = np.nanmax(np.abs(heatmap_array[finite_mask])) if finite_mask.any() else 1
if not np.isfinite(max_abs) or max_abs == 0:
    max_abs = 1
heatmap_masked = np.ma.masked_invalid(heatmap_array)

plt.figure(figsize=(12,5))
fig, ax = plt.subplots(figsize=(12, 5))
im = ax.imshow(
    heatmap_masked,
    cmap="RdYlGn",
    aspect="auto",
    vmin=-max_abs,
    vmax=max_abs,
)
ax.set_xticks(range(len(pivot.columns)))
ax.set_xticklabels(pivot.columns, rotation=45, ha="right")
ax.set_yticks(range(len(pivot.index)))
ax.set_yticklabels([str(y) for y in pivot.index])
ax.set_title("Monthly Return Heatmap")
cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
cbar.set_label("% Return")

for i, year in enumerate(pivot.index):
    for j, month in enumerate(pivot.columns):
        value = pivot.iloc[i, j]
        if pd.notna(value):
            ax.text(j, i, f"{value:.1f}", ha="center", va="center", fontsize=8, color="black")

plt.tight_layout()
show_plot("Monthly Return Heatmap")

# Seasonal avg
seasonal = mdf.groupby("Month")['Return'].mean().reindex(month_order)
plt.figure(figsize=(10,4))
seasonal.plot(kind='bar', color='black')
plt.title("Seasonal Monthly Average Return")
show_plot("Seasonal Monthly Average Return")

# Prepare analysis summary for AI context
latest_price = df['Close'].iloc[-1]
latest_rsi = df['RSI'].iloc[-1]
price_change_pct = ((df['Close'].iloc[-1] - df['Close'].iloc[0]) / df['Close'].iloc[0]) * 100
avg_volatility = df['Volatility'].mean()
current_volatility = df['Volatility'].iloc[-1]

ma_signal = "neutral"
if df['Close'].iloc[-1] > df['MA_50'].iloc[-1] > df['MA_200'].iloc[-1]:
    ma_signal = "bullish (Golden Cross pattern)"
elif df['Close'].iloc[-1] < df['MA_50'].iloc[-1] < df['MA_200'].iloc[-1]:
    ma_signal = "bearish (Death Cross pattern)"

rsi_signal = "neutral"
if latest_rsi > 70:
    rsi_signal = "overbought (>70)"
elif latest_rsi < 30:
    rsi_signal = "oversold (<30)"

analysis_summary = """
ðŸ“Š Stock Analysis Summary:
- Date Range: """ + str(df.index.min().date()) + """ to """ + str(df.index.max().date()) + """
- Total Trading Days: """ + str(len(df)) + """
- Current Price: $""" + f"{latest_price:.2f}" + """
- Price Change: """ + f"{price_change_pct:.2f}" + """% over period
- RSI (14-day): """ + f"{latest_rsi:.2f}" + """ (""" + rsi_signal + """)
- Current Volatility: """ + f"{current_volatility:.2f}" + """%
- Average Volatility: """ + f"{avg_volatility:.2f}" + """%
- Moving Average Signal: """ + ma_signal + """
- 50-Day MA: $""" + f"{df['MA_50'].iloc[-1]:.2f}" + """
- 200-Day MA: $""" + f"{df['MA_200'].iloc[-1]:.2f}" + """
"""

# Return the summary to JavaScript
analysis_summary
      `);
      
      // Store the analysis summary in context and auto-request recommendation
      contextData = pyodide.runPython('analysis_summary');
      document.getElementById("output").innerHTML += "<p style='color: green;'><b>âœ“ Analysis complete!</b></p>";
      
      // Automatically get AI recommendation
      await getAIRecommendation();
      } catch (error) {
        document.getElementById("output").innerHTML = `<p style='color: red;'><b>Error:</b> ${error.message}</p>`;
        console.error(error);
      }
    }

    document.getElementById("fileInput").addEventListener("change", async (evt) => {
      const file = evt.target.files[0];
      if (!file) {
        document.getElementById("analyzeBtn").disabled = true;
        return;
      }
      
      const arrayBuffer = await file.arrayBuffer();
      uploadedFileContent = new Uint8Array(arrayBuffer);
      
      document.getElementById("output").textContent = `File "${file.name}" loaded. Click Analyze to process.`;
      document.getElementById("charts").innerHTML = "";
      document.getElementById("analyzeBtn").disabled = false;
    });

    document.getElementById("analyzeBtn").addEventListener("click", async () => {
      if (!uploadedFileContent) {
        alert("Please upload a CSV file first.");
        return;
      }
      await analyzeCSV(uploadedFileContent);
    });
  </script>
</body>
</html>
